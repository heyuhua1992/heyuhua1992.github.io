<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo+next设置相关]]></title>
    <url>%2F2018%2F09%2F08%2Fhexo%2Bnext%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[学习如何使用 构建自己的博客hexo-如何生成一篇新的post个性化配置 配置 写文章 hexo支持用markdown写作，在目录blog/source/_posts新建markdown文件，或者使用命令hexo new posts “你的文章标题”(有空格时必须加引号) 默认配置文件中设置的default_layout: post，所以也可以用 hexo new “你的文章标题”(有空格时必须加引号) 小坑：&#123;&#123;&#125;&#125;符号编译出错 markdown生成静态页面，&#123;&#123;&#125;&#125;是swig模板符号，属于特殊字符，在编译时解析不了双大括号中间字符串就会报错 解决方案：用转义字符代替12&#123; -&gt; &amp;#123; — 大括号左边部分Left curly brace&#125; -&gt; &amp;#125; — 大括号右边部分Right curly brace 添加文章分类页 cd blog hexo new page categories 修改blog/source/categories/index.md 文件1234title: 分类date: 2018-09-08 15:22:17type: categoriescomments: false #不开启评论功能 vi blog/themes/next/_config.yml 把 #categories: /categories/ || th 前面的#去掉 添加标签分类页 cd blog hexo new page tags 修改blog/source/tags/index.md 文件1234title: 标签date: 2018-09-08 15:35:44type: tagscomments: false vi blog/themes/next/_config.yml 把 #tags: /tags/ || tags 前面的#去掉 添加404页面 把写好的404.html 页面放到 blog/themes/next/source 切换主题 vi blog/themes/next/_config.yml12345# Schemes #scheme: Muse #scheme: Mist scheme: Pisces #scheme: Gemini 百度统计 注册百度统计，管理 &gt; 网站列表 &gt; 新增网站完成后，代码管理 &gt; 代码获取，就能得到统计id123456789&lt;script&gt;var _hmt = _hmt || [];(function() &#123; var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?4cb26b281687c7ae654b8b53e58b1bff"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;/script&gt; vi blog/themes/next/_config.yml 把 #baidu_analytics: 改为 baidu_analytics: 4cb26b281687c7ae654b8b53e58b1bff 不蒜子统计 不蒜子统计可以统计站点以及每个页面的PV、UV和站点总的访问数，以小眼睛的形式展现。 编辑主题配置文件中的busuanzi_count的配置项。当enable: true时，代表开启全局开关。若total_visitors、total_views、post_views的值均为false时，不蒜子仅作记录而不会在页面上显示。 在使用localhost:4000的时候会出现访问人数很多的情况，因为这个ip大家测试的时候在用 只有gemini、pisces主题才有这个功能（默认主题为muse） 评论功能 之 gitment配置 vi blog/themes/next/_config.yml 改之后12345678910111213gitment: enable: true mint: true count: true lazy: false cleanly: false language: zh-CN github_user: heyuhua1992@163.com github_repo: heyuhua1992.github.io client_id: a27075a2e647766f5b61 client_secret: f2d60a60dce31a5de44588da0f3ef35669c0885b proxy_gateway: redirect_protocol: 开启enable为true就显示评论框了，不过要真正实现评论可用，需要 用自己的github账号注册一个应用许可证书，即OAuth application，注册成功就生成了client_id和client_secret。 步骤：你的github首页 &gt; settings &gt; Developer settings &gt; OAuth Apps &gt; New oAuth App。填写好相关信息，其中，Homepage URL和Authorization callback URL都写上你的github博客首页地址，比如https://xxx.github.io/，点击Register application即可完成注册，生成Client ID和Client Secret 底部建站时间和图标修改 改后123456789101112icon: name: user color: &quot;#23ade5&quot;copyright:powered: enable: false version: falsetheme: enable: false version: false 侧边栏社交链接 vi blog/themes/next/_config.yml 改后12social: GitHub: https://github.com/heyuhua1992 || github 添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：1npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true Hexo-admin Hexo-admin插件允许我们直接在本地页面上修改文章内容。 下载 cd /blog1npm i hexo-admin --save 登录http://localhost:4000/admin即可看到我们所有的文章内容，并且在可视化界面中操作文章内容 在网站首页只显示每篇文章的部分内容，不要全部内容都展示出来。 123auto_excerpt:enable: true # 显示阅读全文length: 150 要注意的问题 有些文章评论初始化弹出validation failed错误 因为GitHub的每个issues有两个lables，一个是gitment，另一个是id，id取的是页面pathname，标签长度限定不超过50个字符，而像一般中文标题文章，转义后字符很容易超过50个字符 目录blog/themes/next/layout/_third-party/comments找到文件gitment.swig 把 id: window.location.pathname, 改为 id: &#123;&#123;page.date&#125;&#125;, 在这里我用文章创建时间戳来当作id，这样长度就不会超过50个字符，成功解决！]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex 布局]]></title>
    <url>%2F2017%2F07%2F23%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[flex弹性布局相关属性 详细参考：阮一峰博客 1.flex-direction 定义沿水平或主轴方向 row（默认值）：主轴为水平方向，起点在左端。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[daily reading note]]></title>
    <url>%2F2017%2F04%2F02%2Fdaily%20reading%20note%2F</url>
    <content type="text"><![CDATA[记录日常看书、看博客小记DOM2 DOM3有关属性检测节点是否相等 isSomeNode isEqualNode 123456div1 = document.createElement(&quot;div&quot;);div2 = document.createElement(&quot;div&quot;);div1.isSameNode(div1); // truediv1.isSameNode(div2); // falsediv1.isEqualNode(div2); // true 获取框架文档对象 contentDocument contentWindow 12var iframe = document.getElementById(&quot;myIframe&quot;);var iframeDoc = iframe.contentDocument || iframe.contentWindow.document; 获取行间样式遇到float要用styleFloat 1myDiv.styleFloat = &quot;left&quot;; 几个重要样式属性和方法 cssText length item(index) getPropertyValue(propertyName) removeProperty(propertyName) setProperty(propertyName, value, priority) 123456789var demo = document.getElementById(&quot;demo&quot;);var prop, val, i, len;for(var i = 0, len = demo.style.length; i &lt; len; i++) &#123; prop = demo.style[i]; val = demo.style.getPropertyValue(prop); console.log(prop, val);&#125; 计算样式 computedStyleie9-使用oDiv.currentStyle123var computedStyle = document.getComputedStyle(oDiv, null);var bl = computedStyle.borderLeftStyle; 对样式表操作 12345var sheet = null;for(var i = 0, len = document.styleSheets.length; i++) &#123; sheet =document.styleSheets[i]; console.log(sheet.href);&#125; 123456var sheet = document.styleSheets[0];var rules = sheet.cssRules || sheet.rules;var value = rules[0];rule.style.backgroundColor = &quot;red&quot;;// 插入一条样式到样式表sheet.insertRule(&quot;body&quot;, &quot;background-color:red;&quot;, 0); ——2017/11/24 样式相关偏移量 offsetHeight = 元素高度 + （可见）水平滚动条高度 + 上边框高度 + 下边框高度； offsetWidth = 元素宽度 + （可见）垂直滚动条宽度 + 左边框高度 + 右边框高度； offsetLeft = 元素左边框至包含元素的左内边框之间的像素距离； offsetTop = 元素上边框至包含元素的上内边框之间的像素距离； 123456789101112// 想知道某个元素再页面上的偏移量function getElementLeft(ele) &#123; var actualLeft = ele.offsetLeft; var current = ele.offsetParent; while(current !== null) &#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft;&#125; 客户区大小 clientWidth = 元素内容区宽度 + 左右内边距宽度； clientHeight = 元素内容区高度 + 左右内边距高度； 滚动大小 scrollHeight: 在没有滚动条的情况下，元素内容的总高度； scrollWidth: 在没有滚动条的情况下，元素内容的总宽度； scrollLeft: 被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。 scrollTop: 被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。 PS：在不包含滚动条的页面而言，scrollWidth与clientWidth，scrollHeight与clientHeight的关系并不是十分清晰。 Firefox，这两组属性始终相等，但大小代表的是文档内容区域的实际尺寸，而非视口尺寸； Oprea、safari、chrome中这两组属性有差别，其中scrollWidth和scrollHeight等于视口大小，而clientWidth和clientHeight等于文档区域大小； IE，这两组属性不相等，scrollHeight和scrollWidth等于文档内容区域大小，而clientHeight和clientWidth等于视口大小； 所以，我们一般采用获取最大值，保证跨浏览器准确： 1var docHeight = Math.max(document.documentElement.scrollHeight, doucument.documentElment.clientHeight); 确定元素大小 getBoundingClientRect()方法，返回一个对象，包括四个属性：left、top、right和bottom。这些属性给出了元素相对视口的位置。 ——2017/11/26 范围 selectNode() 选择整个节点 selectNodeContents() 只选择节点的子节点 html1&lt;p id=&quot;p1&quot;&gt;&lt;b&gt;Hello&lt;/b&gt;World!&lt;/p&gt; js 12345678910var p1 = document.getElementById(&quot;p1&quot;), helloNode = p1.firstChild.firstChild, worldNode = p1.lastChild, range = document.createRange();var span = document.createElement(&quot;span&quot;);span.style.color = &quot;red&quot;;range.selectNode(helloNode); // 选择整个节点range.surroundContents(span); // 包含选择的节点 123456range.deleteContents(); // 删除范围选区var fragment = range.extractContents(); // 移除范围选区，返回文档片段var fragment = range.cloneContents(); // 赋值范围选区span.appendChild(document.createTextNode(&quot;Inserted Text&quot;));range.insertNode(span); // 在选区前插入一个节点 事件为了兼容所有浏览器，一般对元素添加、删除事件做如下处理（不过一般IE9+都没有必要这么做） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192var EventUtil = &#123; // 添加事件 addHandler: function(element, type, handler) &#123; if(element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else if(element.attachEvent) &#123; element.attachEvent(&quot;on&quot; + type, handler); &#125; &#125;, // 获取事件对象 getEvent: function(ev) &#123; return ev ? ev : window.event; &#125;, // 获取事件目标 getTarget: function(ev) &#123; return ev.target || ev.srcElement; &#125;, // 阻止默认事件 preventDefault: function(ev) &#123; if(ev.preventDefault) &#123; ev.preventDefault(); &#125; else &#123; ev.returnValue = false; &#125; &#125;, // 移除事件 removeHandler: function(element, type, handler) &#123; if(element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if(element.detachEvent) &#123; element.detachEvent(&quot;on&quot; + type, handler); &#125; &#125;, // 阻止冒泡 stopPropagation: function(ev) &#123; if(ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 获取相关元素 getRelatedTarget: function(ev) &#123; if(ev.relatedTarget) &#123; return ev.relatedTarget; &#125; else if(ev.toElement) &#123; return ev.toElement; &#125; else if(ev.fromElement) &#123; return ev.fromElement; &#125; &#125;, // 获取鼠标滚动 getWheelDelta: function(ev) &#123; // 其他 对应mousewheel事件 if(ev.wheelDelta) &#123; return ev.wheelDelta; &#125; // 兼容Firefox 对应DOMMouseScroll else &#123; return -ev.detail * 40; &#125; &#125;, // 获取keypress按下键字符的ASCLL码 getCharCode: function(ev) &#123; if(typeof ev.charCode == &quot;number&quot;) &#123; return ev.charCode; &#125; else &#123; return ev.keyCode; &#125; &#125;, // 获取剪贴板数据 getClipboardText: function(ev) &#123; var clipboardData = (event.clipboardData || window.clipboardData); return clipboardData.getData(&quot;text&quot;); &#125;, // 设置剪贴板数据 setClipboardText: function(ev, value) &#123; if(ev.clipboardData) &#123; return event.clipboardData.setData(&quot;text/plain&quot;, value); &#125; else if(window.clipboardData)&#123; return window.clipboardData.setData(&quot;text&quot;, value); &#125; &#125;&#125;; 扫盲：以前认为在页面卸载的时候没有办法去控制，当初没有注意到window下的beforeunload事件 12345EventUtil.addHandler(window, &quot;beforeunload&quot;, function(ev) &#123; var msg = &quot;before unload?&quot;; ev.returnValue = &quot;before unload?&quot;; return &quot;before unload ?&quot;;&#125;); 新认识一个事件，DOMContentLoaded事件在形成完整的DOM数之后就触发，不会理会图片、JavaScript文件、css文件或其他资源是否已经下载完毕。 —— 2017/11/27 自定义事件123456789101112131415EventUtil.addHandler(selfBtn, &quot;myEvent&quot;, function(ev) &#123; ev = EventUtil.getEvent(ev); console.log(&quot;btn myEvent:&quot;, ev.detail);&#125;);EventUtil.addHandler(document, &quot;myEvent&quot;, function (ev) &#123; ev = EventUtil.getEvent(ev); console.log(&quot;document myEvent:&quot;, ev.detail);&#125;);var event = document.createEvent(&quot;CustomEvent&quot;);event.initCustomEvent(&quot;myEvent&quot;, true, false, &quot;hello my event&quot;);selfBtn.dispatchEvent(event); —— 2017/12/6 表单form表单作为一种古老的数据提交方式，很多细节还真是头回见，下面小记下。 1234567891011121314&lt;form action=&quot;http://xxx.com&quot; method=&quot;post&quot; id=&quot;form1&quot;&gt; &lt;p&gt; &lt;label&gt;姓名：&lt;/label&gt; &lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;username&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;username&quot;&gt; &lt;select name=&quot;gender&quot;&gt; &lt;option value=&quot;0&quot;&gt;男&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;女&lt;/option&gt; &lt;/select&gt; &lt;/p&gt;&lt;/form&gt; 123var forms = document.forms // 获取页面中所有form集合var firstForm = document.forms[0]; // 索引获取表单var form1 = document.forms[&quot;form1&quot;]; // 根据名称获取表单 单击一下代码生成的按钮，可以提交表单 123&lt;input type=&quot;submit&quot; value=&quot;Submit form&quot;&gt;&lt;button type=&quot;submit&quot; &gt;Submit form&lt;/button&gt;&lt;input type=&quot;image&quot; src=&quot;demo.png&quot;&gt; 这种方式提交表单，浏览器会将请求发送到服务器之前触发submit事件。 123var form = document.querySelector(&quot;form&quot;);var firstField = form.elements[0];var field1 = form.elements[&quot;name&quot;]; 除了元素外，所有表单字段拥有相同的一组属性：disabled、form、name、readonly、tabIndex、type、value。 值得注意的是，对value属性所做的修改，不一定会反映在DOM中，因此，在处理文本框的值时，最好不要使用DOM方法。 为解决不知道用户选择了什么文本的困扰，新认识了两个属性：selectionStart、selectionEnd。 12345678$name.addEventListener(&quot;select&quot;, function(ev) &#123; if(typeof $name.selectionStart == &quot;number&quot;) &#123; console.log($name.value.substring($name.selectionStart, $name.selectionEnd)); &#125; else if(document.selection) &#123; // IE8- console.log(document.selection.createRange().text); &#125;&#125;); 设置选中部分文本解决方案：setSelectionRange 123$name.value = &quot;hello form&quot;;$name.setSelectionRange(0, 4); // hel$name.focus(); 复制&amp;&amp;粘贴问题解决方案：event.clipboardData/window.clipboardData获取到clipboardData对象，有setData和getData方法。只有opera不支持。Firefox、safari和chrome只允许在paste事件发生时读取剪贴板数据，而ie没有这个限制。 以前对select的操作过于依赖jQuery或者DOM操作，其实本身有些很好的方法和属性。HTMLSelectElement提供的一些属性和方法： add(newOption, relOption)：向控件中插入新元素，其位置在相关项relOption之前。 multiple：是否允许多项选择。 options：控件中所有元素的HTMLCollection。 remove(index)：移除给定位置的选项。 selectedIndex：基于0的选中项索引，没有选中项，返回-1.对于多选项，只返回选中项中的第一项索引。 size：选择框中可见行数。 HTMLOptionElement有一下属性： index：当前选项在options集合中的索引。 label：当前选项的标签。 selected：当前选项是否被选中。将这个属性设置位true可以选中当前选项。 text：选项的文本。 value：选项的值。 1234567&lt;select name=&quot;is-student&quot; id=&quot;is-student&quot;&gt; &lt;option value=&quot;0&quot;&gt;否&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;是&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;不清楚&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;不明白&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;不知道&lt;/option&gt;&lt;/select&gt; 123456789101112131415options = $isStudent.options;// 将第四位置上的option元素插入到第二位前面$isStudent.add(options[3], options[1]);// 移除第五位option元素$isStudent.remove(4);// 将第三项选中options[2].selected = true;console.log(&quot;选中了的项索引：&quot;, $isStudent.selectedIndex); // 2console.log(&quot;选中项的文本：&quot;, options[$isStudent.selectedIndex].text); // 是console.log(&quot;选中项的标签：&quot;, options[$isStudent.selectedIndex].label); // 是console.log(&quot;选中项的在options集合中的索引：&quot;, options[$isStudent.selectedIndex].index); // 2 —— 2017/12/8 typeof undefined以前总迷惑，为嘛能够直接 1if(aaa === undefined) 看到别人偏偏 1if(typeof aaa == &quot;undefined&quot;) 今天才明白其中道理：因为在js中undefined可以被重写，这样防止页面中有undefined变量存在。下面来看看区别： 1234567891011(function(undefined) &#123; var a; console.log(&quot;test1: &quot;, a === undefined); // false console.log(&quot;test1: &quot;, &quot;abc&quot; === undefined); // true&#125;)(&quot;abc&quot;);(function(undefined) &#123; // var a; console.log(&quot;test2: &quot;, typeof a === &quot;undefined&quot;); // true console.log(&quot;test2: &quot;, &quot;abc&quot; === undefined); // true&#125;)(&quot;abc&quot;); 作用于安全构造函数构造函数其实是一个使用new操作符调用的函数。当使用new调用时，构造函数内用到的this对象会指向新创建的对象实例。 12345678function Person(name, age) &#123; this.name = name; this.age = age;&#125;var person = new Person(&quot;wuwh&quot;, &quot;22&quot;);console.log( person.name );console.log( person.age ); 如果构造函数被当作普通函数调用，this就会指向window对象，添加成window下的属性。 123var person = Person(&quot;wuwh&quot;, &quot;22&quot;);console.log(window.name);console.log(window.age); 解决这个问题的方法时创建一个作用域安全的构造函数，原理是在进行任何更改前，确认this对象是指向正确的实例。 123456789function Person(name, age) &#123; if(this instanceof Person) &#123; this.name = name; this.age = age; &#125; else &#123; return new Person(name, age); &#125;&#125; —— 2017/12/9 HTML5原生APIXDM 跨文档消息传送（XDM）,HTML5原生提供了postMessage方法。 postMessage()方法接收两个参数： 一条消息 一个表示消息接收方来自哪个域下的字符串 1234var frameWindow = document.querySelector(&quot;iframe&quot;).contentWindow;setTimeout(function() &#123; frameWindow.postMessage(&quot;hello&quot;, &quot;http://localhost&quot;);&#125;, 1000); 接收到XDM消息时，会触发window对象的message事件，改事件会包含三个重要信息： data：postMessage()第一个参数； origin：发送消息的文档所在的域； source：发送消息的文档window对象的代理，用于发送上一条消息的窗口中调用postMessage()。 1234567// 接收XDM消息window.addEventListener(&quot;message&quot;, function(ev) &#123; console.log(&quot;ev.origin:&quot;, ev.origin); console.log(&quot;ev.data:&quot;, ev.data); console.log(&quot;ev.source:&quot;, ev.source); ev.source.postMessage(&quot;Received!&quot;, &quot;http://localhost&quot;);&#125;); 拖放事件 在被拖动元素上依次触发事件： dragstart drag dragend 在防止目标上依次触发事件： dragenter dragover dragleave drop为了阻止默认行为，一般都要对dragenter、dragover和drop绑定阻止默认事件。 认识一个新的事件属性dataTransfer，用于从被拖放元素向放置目标传递字符串格式的数据。 123456789// 设置文本和url数据ev.dataTransfer.setData(&quot;URL&quot;, location.href);ev.dataTransfer.setData(&quot;text&quot;, &quot;hello drag&quot;);// 接收文本和url数据console.log(&quot;dataTransfer url:&quot;, dataTransfer.getData(&quot;URL&quot;) || dataTransfer.getData(&quot;text/uri-list&quot;));console.log(&quot;dataTransfer text:&quot;, dataTransfer.getData(&quot;text&quot;));console.log(&quot;dataTransfer file:&quot;, dataTransfer.file); —— 2017/12/9 高级函数惰性载入函数 有时候对浏览器的检测，我们执行一次就行，不必每次调用进行分支检测。解决方案就是惰性载入。 在第一次调用过程中，该函数被覆盖为另一个合适方式执行的函。 1234567891011121314function createXHR() &#123; if(typeof XMLHttpRequest != &quot;undefined&quot;) &#123; createXHR = function() &#123; return new XMLHttpRequest(); &#125; &#125; else if(typeof ActiveXObject != &quot;undefined&quot;) &#123; createXHR = function() &#123; return new ActiveXObject(&quot;MSXML2.XMLHTTP&quot;); &#125; &#125; return createXHR();&#125; 函数声明时就自执行指定恰当的函数。 1234567891011121314var createXHR = (function () &#123; if(typeof XMLHttpRequest != &quot;undefined&quot;) &#123; createXHR = function() &#123; return new XMLHttpRequest(); &#125; &#125; else if(typeof ActiveXObject != &quot;undefined&quot;) &#123; createXHR = function() &#123; return new ActiveXObject(&quot;MSXML2.XMLHTTP&quot;); &#125; &#125; return createXHR();&#125;)(); 函数绑定 指定一个函数内this环境，ES5原生可以用bind，bind实现原理时这样的： 12345function bind(fn, context) &#123; return function() &#123; fn.apply(context, arguments); &#125;&#125; bind一般用于事件处理程序以及setTimeout()和setInterval()。因为这些直接用函数名，函数体内this时分别指向元素和window的。 函数柯里化 上面模拟绑定函数的实现，发现不能传参。于是，对绑定函数进行传参处理叫做函数柯里化。 实现可以传参的bind函数。 12345678function bind(fn, context) &#123; var args = Array.prototype.slice.call(arguments); return function() &#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(context, finalArgs); &#125;&#125; 防止篡改对象 Object.preventExtensions() 防止给对象添加新属性和方法。 123456var person = &#123; name: &quot;wuwh&quot;&#125;;Object.preventExtensions(person);person.age = 22;console.log(person.age); // undefined Object.seal() 防止删除对象属性和方法。 123456var person = &#123; name: &quot;wuwh&quot;&#125;;Object.seal(person);delete person.name;console.log(person.name); // wuwh Object.freeze() 冻结对象，既不可以拓展，也不可以密封，还不可以修改。 12345678910var person = &#123; name: &quot;wuwh&quot;&#125;;Object.freeze(person);person.age = 22;console.log(person.age); // undefineddelete person.name;console.log(person.name); // wuwhperson.name = &quot;xiohua&quot;;console.log(person.name); // wuwh 定时器 理解这段话就明白为什么setInterval要谨慎使用了。 使用setInterval()创建的定时器确保了定时器代码规则地插入到队列中。问题在于，定时器代码可能在被添加到队列之前还没有完成执行，结果导致定时器代码运行好几次，而之间没有停顿。在这里js引擎避免了这个问题。当时用setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。确保了定时器代码加入到队列地最小时间间隔为指定间隔。 造成后果：(1)某些间隔被跳过；(2)多个定时器地代码执行之间地间隔可能会比预期地小。 —— 2017/12/13 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/**自定义事件基于观察者设计模式* handlers = &#123;* type1: [eventFn1_1, event1_2, ...],* type2: [eventFn2_1, event2_2, ...]*&#125;*/function EventTarget() &#123; this.handlers = &#123;&#125;;&#125;EventTarget.prototype = &#123; constructor: EventTarget, // 添加一个自定义事件 addHandler: function(type, handler) &#123; if(typeof this.handlers[type] == &quot;undefined&quot;) &#123; this.handlers[type] = []; &#125; this.handlers[type].push(handler); &#125;, // 遍历执行自定义事件程序 fire: function(ev) &#123; if(!ev.target) &#123; ev.target = this; &#125; if(this.handlers[ev.type] instanceof Array) &#123; var handlers = this.handlers[ev.type]; for(var i = 0, len = handlers.length; i &lt; len; i++) &#123; handlers[i](ev); &#125; &#125; &#125;, // 移除一个自定义事件程序 removeHandler: function(type, handler) &#123; if(this.handlers[type] instanceof Array) &#123; var handlers = this.handlers[type]; for(var i = 0, len = handlers.length; i &lt; len; i++) &#123; if(handlers[i] === handler) &#123; handlers.splice(i, 1); break; &#125; &#125; &#125; &#125;&#125;var DragDrop = function (selector) &#123; var dragdrop = new EventTarget(); var draging = null, diffX = 0, diffY = 0; var target = document.querySelector(selector); function handleEvent(ev) &#123; switch (ev.type) &#123; case &quot;mousedown&quot;: draging = target; diffX = ev.clientX - draging.offsetLeft; diffY = ev.clientY - draging.offsetTop; // 触发自定义事件 dragdrop.fire(&#123; type: &quot;dragstart&quot;, target: draging, x: ev.clientX, y: ev.clientY &#125;); break; case &quot;mousemove&quot;: if (draging !== null) &#123; draging.style.left = (ev.clientX - diffX) + &quot;px&quot;; draging.style.top = (ev.clientY - diffY) + &quot;px&quot;; &#125; // 触发自定义事件 dragdrop.fire(&#123; type: &quot;drag&quot;, target: draging, x: ev.clientX, y: ev.clientY &#125;); break; case &quot;mouseup&quot;: case &quot;mouseout&quot;: // 触发自定义事件 dragdrop.fire(&#123; type: &quot;dragend&quot;, target: draging, x: ev.clientX, y: ev.clientY &#125;); draging = null; break; &#125; ev.stopPropagation(); &#125; // 单例提供出去的公共接口 dragdrop.enable = function () &#123; target.addEventListener(&quot;mousedown&quot;, handleEvent, false); target.addEventListener(&quot;mousemove&quot;, handleEvent, false); target.addEventListener(&quot;mouseup&quot;, handleEvent), false; target.addEventListener(&quot;mouseout&quot;, handleEvent), false; &#125;; dragdrop.disable = function () &#123; target.removeEventListener(&quot;mousedown&quot;, handleEvent); target.removeEventListener(&quot;mousemove&quot;, handleEvent); target.removeEventListener(&quot;mouseup&quot;, handleEvent); &#125; return dragdrop;&#125;;var dg = DragDrop(&quot;#drag&quot;);dg.addHandler(&quot;drag&quot;, function(ev) &#123; console.log(ev.x);&#125;);dg.enable(); —— 2017/12/14 ES6之SymbolSymbol是ES6中引入的一个第七种数据类型（前六种分别是undefined、null、Boolean、String、Number、Object）。目的是使得属于Symbol类型的属性都是独一无二的，可以保证不与其他属性名产生冲突。 Symbol函数相同入参，返回值不相等 123let sym1 = Symbol(&quot;my symbol&quot;);let sym2 = Symbol(&quot;my symbol&quot;);console.log(sym1 == sym2); // false Symbol值不能和其他类型的值进行运算，包括自身。但是可以显示转化成字符串，也可以转化成布尔值 1234let sym = Symbol(&quot;my symbol&quot;);console.log(Boolean(sym));console.log(sym.toString()); // Symbol(my symbol)console.log(sym + &quot;.gif&quot;); // Uncaught TypeError Symbol值作为对象属性 1234567891011121314let mySymbol = Symbol();let a = &#123;&#125;;a[mySymbol] = &quot;Hello&quot;;console.log(&quot;a:&quot;, a);let b = &#123; [mySymbol]: &quot;Hello&quot;&#125;;console.log(&quot;b:&quot;, b);let c = &#123;&#125;;Object.defineProperty(c, mySymbol, &#123;value: &quot;Hello&quot;&#125;);console.log(&quot;c:&quot;, c); 获取对象所有Symbol属性名 12345678910111213const obj = &#123;&#125;;let a = Symbol(&quot;a&quot;);let b = Symbol(&quot;b&quot;);obj[a] = &quot;Hello&quot;;obj[b] = &quot;World&quot;;const objSymbols = Object.getOwnPropertySymbols(obj);console.log(&quot;Object.getOwnPropertySymbols(obj):&quot;, Object.getOwnPropertySymbols(obj)); // [Symbol(a), Symbol(b)]console.log(&quot;Object.getOwnPropertyNames(obj):&quot;, Object.getOwnPropertyNames(obj)); // []console.log(&quot;Reflect.ownKeys(obj):&quot;, Reflect.ownKeys(obj)); // [Symbol(a), Symbol(b)] Symbol.for() 搜索返回已有参数名称的Symbol值，没有则会新建以改字符串为名称的Symbol值 123456let s1 = Symbol.for(&quot;foo&quot;);let s2 = Symbol.for(&quot;foo&quot;);console.log(&quot;symbol for s1 == s2:&quot;, s1 === s2);// Symbol.keyFor 返回已登记Symbol类型值的keyconsole.log(Symbol.keyFor(s1)); // fooconsole.log(Symbol.keyFor(Symbol(&quot;aaa&quot;))); // undefined Symbol.for登记的名字是全局环境的 123456let iframe = document.createElement(&quot;iframe&quot;);iframe.src = location.href;document.body.appendChild(iframe);console.log(iframe.contentWindow.Symbol.for(&quot;foo&quot;) === window.Symbol.for(&quot;foo&quot;)); ES6之ProxyProxy属于一种“元编程”，即对编程语言进行编程。可以理解成在木匾对象之前架设一层“拦截” 12345678let proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return &quot;wuwh&quot;; &#125;&#125;);console.log(proxy.time); // wuwhconsole.log(proxy.name); // wuwh Proxy实例可以作为其他对象的原型对象 12345678let proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return &quot;wuwh&quot;; &#125;&#125;);let obj = Object.create(proxy);console.log(proxy.time); Proxy的一些实例方法 123456789101112131415161718192021222324let handler = &#123; get: function(target, name) &#123; if(name === &quot;prototype&quot;) &#123; return Object.prototype; &#125; return &quot;Hello, &quot; + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123;value: args[1]&#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);console.log(fproxy(1, 2)); // 1 被apply拦截console.log(new fproxy(1, 2)); // &#123;value: 2&#125; 被construct拦截console.log(fproxy.time); // Hello, time 被get拦截 writable和configurable属性都为false时，则该属性不能被代理，通过 Proxy 对象访问该属性会报错 12345678910111213141516let obj = &#123;&#125;; Object.defineProperty(obj, &quot;foo&quot;, &#123; value: 123, writable: false, configurable: false &#125;); const handler = &#123; get: function(target, propKey) &#123; return &quot;wuwh&quot;; &#125; &#125;; const proxy = new Proxy(obj, handler); console.log(proxy.foo); —— 2017/12/15 ES6之ReflectReflect对象与Proxy对象一样，也是ES6为了操作对象提供的新API。 Reflect对象一共有 13 个静态方法。 Reflect.apply(target, thisArg, args) Reflect.construct(target, args) Reflect.get(target, name, receiver) Reflect.set(target, name, value, receiver) Reflect.defineProperty(target, name, desc) Reflect.deleteProperty(target, name) Reflect.has(target, name) Reflect.ownKeys(target) Reflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype) Reflect.get &amp;&amp; Reflect.set 在name属性部署了读取函数（getter）或者是设置函数（setter），this绑定receiver1234567891011121314var obj = &#123; foo: 1, set bar(value) &#123; return this.foo = value; &#125;&#125;;var receiveObj = &#123; foo: 5&#125;Reflect.set(obj, &quot;bar&quot;, 3, receiveObj);console.log(&quot;obj.bar:&quot;, obj.foo);console.log(&quot;receiveObj.bar:&quot;, receiveObj.foo); 如果Proxy对象和Reflect对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入receiver，那么Reflect.set会触发Proxy.defineProperty12345678910111213141516var obj = &#123; name: &quot;wuwh&quot;&#125;;var loggedObj = new Proxy(obj, &#123; set: function(target, key, value, receiver) &#123; console.log(&quot;set...&quot;); Reflect.set(target, key, value, receiver); &#125;, defineProperty(target, key, attribute) &#123; console.log(&quot;defineProperty...&quot;); Reflect.defineProperty(target, key, attribute); &#125;&#125;);loggedObj.name = &quot;xiaohua&quot;; // set... defineProperty... Reflect.constructor(target, args) 123456789function Geeting(name) &#123; this.name = name;&#125;// new 的写法const instance = new Greeting(&quot;张三&quot;);// Reflect.construct的写法const instance = Reflect.construct(Greeting, [&quot;张三&quot;]); Reflect.getPrototypeOf(obj) &amp;&amp; Reflect.setPrototypeOf(obj, newProto) 设置和读取对象的proto属性 12345678910function FancyThing() &#123;&#125;const myObj = new FancyThing();const obj = &#123; constructor: FancyThing, name: &quot;wuwh&quot;&#125;;Reflect.setPrototypeOf(myObj, obj);console.log(Reflect.getPrototypeOf(myObj)); // obj Reflect.ownKeys123456789101112var obj = &#123; foo: 1, bar: 2, [Symbol.for(&quot;foo&quot;)]: 3, [Symbol.for(&quot;baz&quot;)]: 4&#125;;console.log(Object.getOwnPropertyNames(obj)); // [&quot;foo&quot;, &quot;bar&quot;]console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(foo), Symbol(baz)]console.log(Reflect.ownKeys(obj)); // [&quot;foo&quot;, &quot;bar&quot;, Symbol(foo), Symbol(baz)] ES6之Set和Mapset Set是ES6新数据结构，类似于数组，但是成员都是唯一的，没有重复的值 12345678var s = new Set();[1, 2, 3, 4, 5, 1, 2, 3].forEach(function(x) &#123; return s.add(x);&#125;);for(let i of s) &#123; console.log(&quot;set i:&quot;, i);&#125; 可以看成是一种数组的去重方法 变量解构 123456const set = new Set([1, 2, 3, 4, 1, 2, 3]);console.log([...set]); *//* // 在Set内部，两个NaN是相等的let set = new Set([NaN, NaN]);console.log(set); //Set &#123;NaN&#125; 两个对象被视为不相等 12let set1 = new Set([&#123;&#125;, &#123;&#125;]);console.log(set1); // Set &#123;&#123;&#125;, &#123;&#125;&#125; Set的方法 add、delete、clear和has 123456789101112let s = new Set([0, 1]);s.add(2).add(3);console.log(s); // Set &#123;0, 1, 2, 3&#125;console.log(s.has(3)); // trues.delete(2);console.log(s); // Set &#123;0, 1, 3&#125;s.clear();console.log(s); // Set(0) &#123;&#125; 可以看成是一种数组的去重方法 Array.from 12const set = new Set([1, 2, 3, 4, 1, 2, 3]);console.log(Array.from(set)); 实现并集，交集和差集 1234567891011let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);let union = new Set([...a, ...b]);console.log(union); // Set(4) &#123;1, 2, 3, 4&#125;let intersect = new Set([...a].filter(x =&gt; b.has(x)));console.log(intersect); // Set(2) &#123;2, 3&#125;let difference = new Set([...a].filter(x =&gt; !b.has(x)));console.log(difference); // Set(1) &#123;1&#125; 123456// 垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。// 结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。// WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用// WeakSet成员类型只能是对象类型let ws = new WeakSet([1, 2]); // Uncaught TypeError: Invalid value used in weak setconsole.log(ws); Map数据结构类似对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值都可以 1234567891011let m = new Map();let o = &#123;msg: &quot;hello&quot;&#125;;m.set(o, &quot;world&quot;);console.log(m); // Map(1) &#123;&#123;…&#125; =&gt; &quot;world&quot;&#125;console.log(m.get(o)); // worldconsole.log(m.has(o)); // trueconsole.log(m.delete(o)); // trueconsole.log(m.has(o)); // false Map可以接收一个数组作为参数，数组成员是一个个表示键值对的数组 12345678let m = new Map([ [&quot;name&quot;, &quot;wuwh&quot;], [&quot;age&quot;, 22]]);console.log(m); // Map(2) &#123;&quot;name&quot; =&gt; &quot;wuwh&quot;, &quot;age&quot; =&gt; 22&#125;console.log(m.size); // 2console.log(m.get(&quot;name&quot;)); // wuwh 事实上不仅仅是数组，任何具有Iterator接口、 每个成员都是一个双元素的数组，都可以当作Map构造函数的参数 123456789let set = new Set([ [&quot;foo&quot;, 1], [&quot;bar&quot;, 2]]);console.log(set); // Set(2) &#123;Array(2), Array(2)&#125;let m = new Map(set);console.log(m); // Map(2) &#123;&quot;foo&quot; =&gt; 1, &quot;bar&quot; =&gt; 2&#125; 一个键值多次赋值，后面的会覆盖前面的 123let m = new Map();m.set(1, &quot;aaa&quot;).set(1, &quot;bbb&quot;);console.log(m); // Map(1) &#123;1 =&gt; &quot;bbb&quot;&#125; Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键 1234let m = new Map();m.set([&quot;a&quot;], 1);console.log(m.get([&quot;a&quot;])); // undefined forEach方法接受第二个参数，用来绑定this 123456789let reporter = &#123; report: function(key, value) &#123; console.log(key, value); &#125;&#125;;m.forEach(function(value, key, map) &#123; this.report(key, value);&#125;, reporter); —— 2017/12/18 ES6之Promise今天复习一下ES6中Promise的基础用法。ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。Promise对象有两个特点： 对象的状态不受外界影响； 一旦状态改变，就不会再变，任何时候都可以得到这个结果； 优点： 就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。 Promise对象提供统一的接口，使得控制异步操作更加容易。 缺点： 无法取消Promise，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log(&apos;Promise&apos;); resolve();&#125;);promise.then(function() &#123; console.log(&apos;resolved.&apos;);&#125;);console.log(&apos;Hi!&apos;);// Promise// Hi!// resolved Promise实现ajax 123456789101112131415161718192021const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject) &#123; const handler = function() &#123; if (this.readyState == 4) &#123; if (this.status == 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125; &#125;; const xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, url); xhr.onreadystatechange = handler; xhr.responseType = &quot;json&quot;; xhr.send(); &#125;); return promise;&#125; 第一个回调函数完成以后， 会将返回结果作为参数， 传入第二个回调函数。 1234567getJSON(&quot;js/data.json&quot;).then(function(res) &#123; console.log(&quot;then res:&quot;, res); return res;&#125;).then(function(res) &#123; console.log(&quot;then then res:&quot;, res);&#125;); 前一个回调函数，有可能返回的还是一个Promise对象，这时后一个回调函数，就会等待该promise对象的状态发生变化，才会被调用，否则不会被调用。 12345678910getJSON(&quot;js/data.json&quot;).then(function(res) &#123; console.log(&quot;then res:&quot;, res); return getJSON(res.src);&#125;).then(function(res) &#123; console.log(&quot;then then res:&quot;, res);&#125;).catch(function(error) &#123; console.log(&quot;error:&quot;, error.message);&#125;); resolve语句后，抛出错误，不会被捕获，等于没有抛出，Promise状态一旦改变，不会再改变。 12345678910const promise = new Promise(function(resolve, reject) &#123; resolve(&quot;ok&quot;); throw new Error(&quot;wrong&quot;);&#125;);promise.then(function(value) &#123; console.log(&quot;resolve:&quot;, value); // ok&#125;).catch(function(error) &#123; console.log(&quot;reject:&quot;, error.message);&#125;); catch、then中抛出的错误都会一级一级往后冒泡，直到被后面的catch捕获到。 123456789101112131415161718const promise = function() &#123; return new Promise(function(resolve, reject) &#123; resolve(x + 1); &#125;);&#125;;promise() .catch(function(error) &#123; console.error(&quot;error:&quot;, error.message); // error: x is not defined &#125;) .then(function() &#123; console.log(&quot;carry on&quot;); // carry on console.log(&quot;carry on&quot;, y); &#125;) .catch(function(error) &#123; console.error(&quot;error:&quot;, error.message); // error: y is not defined &#125;); p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态123456789101112131415161718192021const p1 = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; console.log(&quot;timeout p1&quot;); resolve(&quot;p1&quot;); &#125;, 3000);&#125;);const p2 = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; console.log(&quot;timeout p2&quot;); resolve(p1); &#125;, 1000);&#125;);p2.then(function(res) &#123; console.log(&quot;p2 res:&quot;, res);&#125;);// timeout p2// timeout p1// p2 res: p1 —— 2017/12/21 ES6之Promise立即resolved的Promise是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务 12345678new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(&quot;resolve...&quot;);&#125;).then(res =&gt; &#123; console.log(res);&#125;);// resolve...// 1 所有Promise实例的状态都变成fulfilled，Promise.all状态才会变成fulfiled只要有一个别被rejected，Promise.all状态就变成rejected 12345678910111213141516171819202122232425262728let getJSON = function(url) &#123; return new Promise(function(resolve, reject) &#123; function handler() &#123; if(this.readyState == 4) &#123; if(this.status == 200 || this.tatus == 304) &#123; resolve(this.response); &#125; else &#123; reject(this.statusText); &#125; &#125; &#125; let xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, url); xhr.onreadystatechange = handler; xhr.responseType = &quot;json&quot;; xhr.send(null); &#125;);&#125;;Promise.all([getJSON(&quot;data/data1.json&quot;), getJSON(&quot;data/data2.json&quot;)]).then(function(res) &#123; console.log(&quot;all success:&quot;, res);&#125;).catch(function(error) &#123; console.log(&quot;error:&quot;, error);&#125;); 其中一个实例状态率先发生改变，Promise.race的状态就跟着改变，这个率先改变实例的返回值作为回调入参 1234567Promise.race([fetch(&quot;data/data1.json&quot;), fetch(&quot;data/data2.json&quot;)]).then(function(res) &#123; console.log(&quot;all success:&quot;, res);&#125;).catch(function(error) &#123; console.log(&quot;error:&quot;, error);&#125;); 立即resolve得Promise对象，是本轮“事件循环”得结束时，而不是下一轮“事件循环”的开始 12345678910111213setTimeout(() =&gt; &#123; console.log(&quot;tree&quot;);&#125;, 0);Promise.resolve().then(function() &#123; console.log(&quot;two&quot;);&#125;);console.log(&quot;one&quot;);// one// two// three Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数 12345678910const thenable = &#123; then(resolve, reject) &#123; reject(&quot;some wrong!&quot;); &#125;&#125;;Promise.reject(thenable).catch(function(error) &#123; console.log(error === thenable); // true&#125;); 捕获最后抛出来的错误 12345678Promise.prototype.done = function(fulfiled, rejected) &#123; this.then(fulfiled, rejected) .catch(function(error) &#123; console.error(error); &#125;);&#125;;Promise.reject().done(); —— 2017/12/22 ES6之Iterator和for…of循环遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 模拟next方法 12345678910111213141516var it = makeIterator([&apos;a&apos;, &apos;b&apos;]);it.next() // &#123; value: &quot;a&quot;, done: false &#125;it.next() // &#123; value: &quot;b&quot;, done: false &#125;it.next() // &#123; value: undefined, done: true &#125;function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;;&#125; 解构、拓展运算符都会默认调用iterator接口覆盖原生遍历器 1234567891011121314151617181920let str = new String(&quot;hi&quot;);console.log([...str]); // [&quot;h&quot;, &quot;i&quot;]str[Symbol.iterator] = function() &#123; return &#123; next: function() &#123; if(this.first) &#123; this.first = false; return &#123;value: &quot;wuwh&quot;, done: false&#125;; &#125; else &#123; return &#123;done: true&#125;; &#125; &#125;, first: true &#125;;&#125;;console.log([...str]); // [&quot;wuwh&quot;] yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 12345678910111213let generator = function* () &#123; yield 1; yield* [2, 3]; yield 4&#125;;let iterator = generator();console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next()); 一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for…of循环遍历它的成员.也就是说,for…of循环内部调用的是数据结构的Symbol.iterator方法for…of循环可以使用的范围包括数组,Set和Map结构,某些类型的数组的对象(arguments对象,DOM NodeList对象)Generator对象以及字符串 DOM NodeList对象部署了iterator接口 12345let ps = document.querySelectorAll(&quot;p&quot;);for(let p of ps) &#123; console.log(p);&#125; for…of能正确识别32位UTF-16字符 123for(let x of &quot;\a\uD83D\uDC0A&quot;) &#123; console.log(x);&#125; 并不是所有类似数组的对象都具有iterator接口 1234567891011let arrayLike = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, length: 2&#125;;for(let x of arrayLike) &#123; console.log(x); // Uncaught TypeError: arrayLike[Symbol.iterator] is not a function&#125;console.log(Array.from(arrayLike)); forEach 缺点:break或return不奏效 12345let arr = [1, 2, 3];arr.forEach(function(item) &#123; console.log(item); if(item &gt; 2) continue; // Uncaught SyntaxError: Illegal break statement&#125;); —— 2017/12/25 ES6之GeneratorGenerator函数调用并不执行,返回的也不是函数运行的结果,而是一个指向内部状态的指针对象,也就是遍历器对象。 123456789101112function * helloWorldGenerator() &#123; yield &quot;hello&quot;; yield &quot;world&quot;; return &quot;ending&quot;;&#125;let hw = helloWorldGenerator();console.log(hw.next()); // &#123;value: &quot;hello&quot;, done: false&#125;console.log(hw.next()); // &#123;value: &quot;world&quot;, done: false&#125;console.log(hw.next()); // &#123;value: &quot;ending&quot;, done: false&#125;console.log(hw.next()); // &#123;value: undefined, done: true&#125; yield表达式只能用在 Generator 函数里面，用在其他地方都会报错 yield表达式在另个一表达式中，必须放在圆括号里面。放在函数参数或放到赋值表达式的右边，可以不加括号。 12345678910111213function foo() &#123;&#125;function* demo() &#123; foo(yield &quot;a&quot;, yield &quot;b&quot;); let input = &quot;abc&quot; +(yield 123);&#125;let f = demo();console.log(&quot;f:&quot;, f);console.log(&quot;f.next():&quot;, f.next());console.log(&quot;f.next():&quot;, f.next());console.log(&quot;f.next():&quot;, f.next());console.log(&quot;f.next():&quot;, f.next()); 任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。 由于Generator函数就是遍历器生成函数，依次可以把Generator赋值给对象的Symbol.iterator,从而使得该对象具有Interator接口。 1234567let myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;console.log([...myIterable]); // [1, 2, 3] Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。 12345function* gen() &#123;&#125;let g = gen();console.log( g[Symbol.iterator]() === g ); // true yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。 123456789101112131415function* foo(x) &#123; let y = 2 * (yield (x + 1)); let z = yield(y / 3); return (x + y + z);&#125;let a = foo(5);console.log(a.next()); // &#123;value: 6, done: false&#125;console.log(a.next()); // &#123;value: NaN, done: false&#125;console.log(a.next()); // &#123;value: NaN, done: true&#125;let b = foo(5);console.log(b.next()); // &#123;value: 6, done: false&#125;console.log(b.next(3)); // &#123;value: 2, done: false&#125;console.log(b.next(6)); // &#123;value: 17, done: true&#125; 遍历斐波拉契数列 1234567891011function* fibonacci(large) &#123; let [prev, curr] = [0, 1]; for(let i = 0; i &lt; large; i++) &#123; [prev, curr] = [curr, prev + curr]; yield curr; &#125;&#125;for(let n of fibonacci(100)) &#123; console.log(n);&#125; 原生对象没有iterator接口，无法用for…of遍历，可以通过Generator函数加上遍历接口。 123456789101112function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); for(let propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125;&#125;let o = &#123;first: &quot;wu&quot;, last: &quot;wh&quot;&#125;;for(let [key, value] of objectEntries(o)) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125; 扩展运算符、解构赋值和Array.from方法内部调用都是遍历器接口。 1234567891011121314151617function* numbers() &#123; yield 1; yield 2; yield 3; return 0; yield 4;&#125;// 扩展运算符console.log([...numbers()]);// Array.from()console.log(Array.from(numbers()));// 解构赋值let [x, y] = numbers();console.log(x, y); 在Generator函数内部，调用另一个Generator函数，默认情况下是没有效果的。 yield* 后面的Generator函数（没有return语句时），等同于在Generator内部部署了一个for…of函数。 1234567891011121314function* foo() &#123; yield &quot;a&quot;; yield &quot;b&quot;;&#125;function* bar() &#123; yield &quot;x&quot;; yield* foo(); yield &quot;y&quot;;&#125;for(let v of bar()) &#123; console.log(v); // &quot;x&quot; // &quot;y&quot;&#125; 被代理的Generator函数有return语句，那么就可以向代理它的Generator函数返回数据。 123456789101112131415161718192021function* foo() &#123; yield 2; yield 3; return &quot;foo&quot;;&#125;function* bar() &#123; yield 1; let v = yield* foo(); console.log(&quot;v: &quot;, v); yield 4;&#125;let it = bar();console.log(it.next()); // &#123;value: 1, done: false&#125;console.log(it.next()); // &#123;value: 2, done: false&#125;console.log(it.next()); // &#123;value: 3, done: false&#125;console.log(it.next()); // v: fooconsole.log(it.next()); // &#123;value: 4, done: false&#125;console.log(it.next()); // &#123; value: undefined, done: true &#125; 将Generator函数内部this指向它的原型上，可以new命令。 1234567891011121314151617181920function* gen() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;function F() &#123; return gen.call(gen.prototype);&#125;var f = new F();// 遍历完后，才会有相应的属性console.log(f.next()); // &#123;value: 2, done: false&#125;console.log(f.next()); // &#123;value: 3, done: false&#125;console.log(f.next()); // &#123;value: undefined, done: true&#125;console.log(f.a); // 1console.log(f.b); // 2console.log(f.c); // 3 return 方法返回给定的值，并且终结遍历Generator函数。 1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;let g = gen();console.log(g.next());g.return(&quot;foo&quot;);console.log(g.next()); Generator函数内部没有部署try…catch，那么throw抛出的错误，被外部try…catch捕获。Generator函数内部和外部，都没有部署try…catch，程序将会报错，中断执行。 123456789101112131415161718192021222324252627function* gen() &#123; while (true) &#123; // try &#123; // yield; // &#125; // catch(e) &#123; // console.log(&quot;内部捕获&quot;, e); // &#125; yield; console.log(&quot;内部捕获&quot;, e); &#125;&#125;;let g = gen();g.next();// g.throw(&quot;a&quot;);// g.throw(&quot;b&quot;);try &#123; g.throw(&quot;a&quot;); g.throw(&quot;b&quot;);&#125;catch (e) &#123; console.log(&quot;外部捕获&quot;, e);&#125; next()、throw()、return()这三个方法本质时同一件事，可以放在一起理解。它们的作用都是让Generator函数恢复执行，并且使用不同的语句替换yield表达式。 12345678910111213141516function* gen(x, y) &#123; let res = yield x + y; return res;&#125;let g = gen(1, 2);console.log(g.next()); // &#123;value: 3, done: false&#125;// 相当于把 let res = yield x + y; 换成 let res = 1;console.log(g.next(1)); // &#123;value: 1, done: true&#125;// 相当于把 let res = yield x + y; 换成 let res = throw(new Error(&quot;something wrong&quot;));g.throw(new Error(&quot;something wrong&quot;)); // Uncaught Error: something wrong// 相当于把 let res = yield x + y; 换成 let res = return 2;console.log(g.return(2)); —— 2017/12/26 ES6之Generator函数的异步应用对于多个异步操作，要等到上一个操作完才执行下一个，这时候就需要封装一个，Generator函数自动执行器。 1234567891011121314151617181920function run(fn) &#123; let g = fn(); function next(err, data) &#123; let res = g.next(data); if (res.done) return; res.value(next); &#125; next();&#125;function* gen() &#123; let f1 = yield readFileThunk(&quot;fileA&quot;); let f2 = yield readFileThunk(&quot;fileB&quot;); // ... let fn = yield readFileThunk(&quot;fileN&quot;);&#125;run(gen); 回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。 Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。 12345678910111213141516171819202122232425262728293031323334// co函数源码function co(gen) &#123; var ctx = this; return new Promise(function (resolve, reject) &#123; if (typeof gen === &apos;function&apos;) gen = gen.call(ctx); if (!gen || typeof gen.next !== &apos;function&apos;) return resolve(gen); onFulfilled(); function onFulfilled(res) &#123; var ret; try &#123; ret = gen.next(res); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; &#125;);&#125;function next(ret) &#123; if (ret.done) return resolve(ret.value); var value = toPromise.call(ctx, ret.value); if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); return onRejected( new TypeError( &apos;You may only yield a function, promise, generator, array, or object, &apos; + &apos;but the following object was passed: &quot;&apos; + String(ret.value) + &apos;&quot;&apos; ) );&#125; —— 2017/12/27 12345678910class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125; 类的数据类型就是函数1console.log(typeof Point); // function 类本身就指向构造函数 1console.log(Point === Point.prototype.constructor); // true 直接对类使用new命令 12let p = new Point(1, 2);console.log(p.toString()); // (1, 2) x和y都是对象point自身的属性（定义在this变量上），toString是原型对象的属性（定义在Point类上） 实例上调用的方法，就是调用原型上的方法1console.log(p.toString === Point.prototype.toString); // true 给实例的原型上添加方法 123456Reflect.getPrototypeOf(p).getX = function() &#123; console.log(this.x);&#125;;let p1 = new Point(3, 4);p1.getX(); // 3 */ 类的属性名，可以采用表达式 1234567891011121314let methodName = &quot;getArea&quot;;class Square &#123; constructor() &#123; &#125; [methodName]() &#123; console.log(&quot;get area...&quot;); &#125;&#125;let sq = new Square();sq.getArea(); // get area... 类中没有定义constructor方法，js引擎会自动为它添加一个空的constructor方法，constructor方法默认返回实例对象，也可以指定返回另一个对象 1234567class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;console.log(new Foo() instanceof Foo); // false 用表达式表示一个类，类的名称是MyClass，Me只在Class内部代码可用，指代当前类，如果内部没有使用到的话，可以省略Me 1234567891011121314151617const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125; get prop() &#123; return &quot;getter&quot;; &#125; set prop(value) &#123; console.log(&quot;setter:&quot; + value); &#125;&#125;;let inst = new MyClass();console.log(inst.getClassName()); // Melet inst1 = new Me(); // Uncaught ReferenceError: Me is not definedconsole.log(inst1.getClassName()); 在类的内部使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为 12inst.prop = 123; // setter:123console.log(inst.prop); // getter for…of循环自动调用遍历器 12345678910111213141516171819202122232425262728293031323334class Foo &#123; constructor(...args) &#123; this.args = args; console.log(&quot;new.target:&quot;, new.target === Foo); &#125; *[Symbol.iterator]() &#123; for(let arg of this.args) &#123; yield arg; &#125; &#125; static sayHi() &#123; return this.returnHi(); &#125; static returnHi() &#123; return &quot;hi&quot;; &#125; returnHi() &#123; return &quot;hello&quot;; &#125;&#125;class Bar extends Foo &#123; static childSayHi() &#123; return super.sayHi() + &quot; child&quot;; &#125;&#125;for(let x of new Foo(&quot;hello&quot;, &quot;world&quot;)) &#123; console.log(x); // hello world&#125; 所有类中定义的方法，都会被实例继承，如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，成为“静态方法”。 静态方法中的this指向Foo类，而不是实例。静态方法可以与非静态方法重名 12console.log(Foo.sayHi()); // hiconsole.log(new Foo().sayHi()); //Uncaught TypeError: (intermediate value).sayHi is not a function 父类的静态方法可以被子类继承 1console.log(Bar.sayHi()); // hi 静态方法可以从super对象上调用 1console.log(Bar.childSayHi()); // hi child 子类继承父类时，new.target会返回子类 1console.log(new Bar()); // false ES6之Class的继承子类必须在constructor方法中调用super方法，否则新建实例时会报错，如果子类没有定义constructor方法，这个方法会被默认添加。在子类构造函数中，只有调用super之后，才可以使用this关键字，否则报错。 123456789101112class ColorPaint extends Point &#123; constructor(x, y, color) &#123; // this.color = color; super(x, y); this.color = color; &#125;&#125;let cp = new ColorPaint(25, 8, &quot;red&quot;);console.log(cp instanceof Point); // trueconsole.log(cp instanceof ColorPaint); // trueconsole.log(Reflect.getPrototypeOf(ColorPaint) === Point); // true super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部this指的是B。 1234567891011121314class A &#123; constructor() &#123; console.log(new.target.name); &#125;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125;new A(); // Anew B(); // B super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中指向父类。 1234567891011121314class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); &#125;&#125;let b = new B(); ES6规定，通过调用父类方法时，方法内部的this指向子类。 12345678910111213141516171819202122class A &#123; constructor() &#123; this.x = 1; &#125; print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; m() &#123; // 实际上执行的是super.print.call(this) super.print(); &#125;&#125;let b = new B();b.m(); // 2 如果super作为对象，用在静态方法中，这时super将指向父类，而不是父类原型对象。 1234567891011121314151617181920212223242526class Parent &#123; static myMethod(msg) &#123; console.log(&quot;static &quot;, msg); &#125; myMethod(msg) &#123; console.log(&quot;instance &quot;, msg); &#125;&#125;class Child extends Parent &#123; static myMethod(msg) &#123; super.myMethod(msg); &#125; myMethod(msg) &#123; super.myMethod(msg); &#125;&#125;// 调用静态方法Child.myMethod(1); // static 1// 调用原型方法var c = new Child(); // instance 2c.myMethod(2); 123456class A &#123; &#125;class B extends A &#123; &#125;console.log(B.__proto__ === A); // trueconsole.log(B.prototype.__proto__ === A.prototype); // true A作为一个基类，就是一个普通函数，所以直接继承Funtion.prototype，A调用后返回一个空对象，所以，A.prototype.proto指向构造函数的prototype属性。 1234class A &#123; &#125;console.log(A.__proto__ === Function.prototype); // trueconsole.log(A.prototype.__proto__ === Object.prototype); // true 原生构造函数可以被继承 12345678910111213141516171819202122232425class VersionedArray extends Array &#123; constructor() &#123; super(); this.history = [[]]; &#125; commit() &#123; this.history.push(this.slice()); &#125; revert() &#123; this.splice(0, this.length, ...this.history[this.history.length - 1]); &#125;&#125;let x = new VersionedArray();x.push(1);x.push(2);console.log(x);console.log(x.history);x.commit();console.log(x.history);x.push(3);console.log(x.history); ES6之Moduleexport 通常情况下，export输出的变量就是本来的名字，但是也可以使用as关键字重命名。 1234567function v1() &#123;&#125;function v2() &#123;&#125;export &#123; v1 as streamV1, v2 as streamV2&#125; export命令规定是对外接口，必须与模块内部变量建立一一对应关系。 1234567891011121314151617// 变量写法一export var m = 1;// 变量写法二var m = 1;export &#123;m&#125;;// 变量写法三var n = 1;export &#123;n as m&#125;;// 函数写法一export function f() &#123;&#125;;// 函数写法二function f() &#123;&#125;export &#123;f&#125;; export语句输出的接口，与其对应的值是动态绑定关系 12export var foo = &apos;bar&apos;;setTimeout(() =&gt; foo = &apos;baz&apos;, 500); importimport命令具有提升效果，会提升到整个模块的头部，首先执行。 123foo();import &#123; foo &#125; from &apos;my_module&apos;; 目前阶段，通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。 注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。 12345import * as circle from &apos;./circle&apos;;// 下面两行都是不允许的circle.foo = &apos;hello&apos;;circle.area = function () &#123;&#125;; export default命令为模块指定默认输出。其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。 第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。 12345678910111213// 第一组export default function crc32() &#123; // 输出 // ...&#125;import crc32 from &apos;crc32&apos;; // 输入// 第二组export function crc32() &#123; // 输出 // ...&#125;;import &#123;crc32&#125; from &apos;crc32&apos;; // 输入 —— 2017/12/28 ES6之Module加载ES6 模块与 CommonJS 模块之间的差异： CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 ES6之编程风格 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。 所有的函数都应该设置为常量。 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this。 注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。 —— 2017/12/28 ES6之数组复制数组 12345const a1 = [1, 2];// const a2 = [...a1];const [...a2] = a1;a2[0] = 2;console.log(&apos;a1:&apos;, a1); // [1, 2] 拓展运算符值会部署了iterator接口的对象转化为数组，包括字符串、Set、Map、generator函数、数组、NodeList等 类似数组的对象（array-like object）和可遍历（iterable）的对象可用Array.from方法转化123456let arrayLike = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, length: 1&#125;;console.log(Array.from(arrayLike)); // [&quot;a&quot;] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 1console.log(Array.from(arrayLike, x =&gt; x.repeat(2))); Array.of方法用于将一组值，转化为数组 12console.log(Array.of(3, 10, 9));console.log(Array.of()); 将指定位置的成员复制到其他位置 1console.log([1, 2, 3, 4, 5].copyWithin(0, 3, 4)); // [4, 2, 3, 4, 5] find找出第一个符合条件数组成员，findIndex找出第一个符合条件数组成员索引 12let f = [1, 3, 5, 7].find(n =&gt; n &gt; 3);console.log(f); fill填充数组 1console.log(new Array(3).fill(6)); fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 1console.log([1, 2, 3, 4].fill(&apos;a&apos;, 1, 4)); // [1, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;] include表示某个数组是否包含给定的值第二个参数表示搜索的起始位置 12console.log([1, 2, 3, NaN].includes(NaN)); //trueconsole.log([1, 2, 3, 4, 5].includes(3, 1)); // true 数组空位相关 1234567891011121314151617181920212223242526272829// 数组空位是没有任何值的console.log(0 in [undefined, undefined, undefined]); // trueconsole.log(0 in [,,]); // falselet arr = [, &apos;a&apos;];// forEach(), filter(), reduce(), every() 和some()都会跳过空位arr.forEach((item, index) =&gt; &#123; console.log(index); // 1&#125;);// join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。console.log([undefined, , &apos;a&apos;].join(&apos;&apos;));// for...of可以遍历到空位for(let i of arr) &#123; console.log(i); // a undefined&#125;// 拓展运算符将空位转为undefinedconsole.log([...[2, , 3]]); // [2, undefined, 3]// Array.from将数组空位转化为undefinedconsole.log(Array.from([4, , 5])); // [4, undefined, 5]// fill()会将空位视为正常数组位置console.log(new Array(3).fill(&apos;a&apos;)); // [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]// entries() 、keys() 、values() 、find()和findIndex()会将空位处理成undefined。 ES6之StringcodePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同。 12345678910111213141516let s = &apos;𠮷&apos;;console.log(s.charCodeAt(0)); // 55362console.log(s.charCodeAt(1)); // 57271console.log(s.codePointAt(0)); // 134071console.log(s.codePointAt(1)); // 57271console.log(s.codePointAt(0).toString(16)); // 134071console.log(s.codePointAt(1).toString(16)); // 57271let text = String.fromCodePoint(0x20bb7, 0xdfb7);// for...of能正确遍历出utf-16字符for(let t of text) &#123; console.log(t);&#125; endsWith的行为与其他两个方法有所不同，它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 1234let str = &apos;Hello world&apos;;console.log(str.startsWith(&apos;llo&apos;, 2)); // trueconsole.log(str.endsWith(&apos;d&apos;, 11)); // trueconsole.log(str.includes(&apos;wo&apos;, 1)); // true repeat() 123456// 小数会被取整console.log(&apos;x&apos;.repeat(3.6)); // &quot;xxx&quot;// 0 - -1 被视为0console.log(&apos;y&apos;.repeat(-0.1)); // &quot;&quot;// 非数字，转化成数字console.log(&apos;z&apos;.repeat(&apos;z&apos;)); // &quot;&quot; padStart() padEnd() 123456789101112// 头部补全console.log(&apos;x&apos;.padStart(5, &apos;ab&apos;)); // &quot;ababx&quot;// 尾部补全console.log(&apos;x&apos;.padEnd(5, &apos;ab&apos;)); // &quot;xabab&quot;// 原字符串长度，等于或大于指定最小长度，则返回原字符串console.log(&apos;xxx&apos;.padStart(3, &apos;ab&apos;)); // &quot;xxx&quot;// 用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串console.log(&apos;xxx&apos;.padStart(5, &apos;abcdef&apos;)); // &quot;abxxx&quot;// 省略第二个参数，默认使用空格补全长度console.log(&apos;xxx&apos;.padStart(5)); // &quot; xxx&quot;console.log(&apos;12&apos;.padStart(10, &apos;YYYY-MM-DD&apos;)); // &quot;YYYY-MM-12&quot; 模板字符串里可以嵌套 1234567891011121314151617181920212223let $body = document.querySelector(&apos;body&apos;);const data = [ &#123;first: &apos;wu&apos;, last: &apos;wenhua&apos;&#125;, &#123;first: &apos;xiao&apos;, last: &apos;hua&apos;&#125;];const temp = d =&gt; ` &lt;table&gt; $&#123;d.map(item =&gt; &#123; return ` &lt;tr&gt; &lt;td&gt;$&#123;item.first&#125;&lt;/td&gt; &lt;td&gt;$&#123;item.last&#125;&lt;/td&gt; &lt;/tr&gt; `; &#125;).join(&apos;&apos;)&#125; &lt;/table&gt;`;console.log(temp(data));$body.innerHTML= temp(data); 执行一段字符串 1234let str = `return ` + &apos;`Hello $&#123;name&#125;`&apos;;let func = new Function(&apos;name&apos;, str);console.log(func);console.log(func(&apos;wuwh&apos;)); 标签模板 123456789101112131415161718function passthru(literals, ...values) &#123; let output = &apos;&apos;; let index; for(index = 0; index &lt; values.length; index++) &#123; output += literals[index] + values[index]; &#125; output += literals[index]; return output;&#125;let name = &apos;wen&apos;;let age = 22;let str = passthru`My name is $&#123;name&#125;, I am $&#123;age&#125; old`; // tag函数调用console.log(str); tag函数的第一个参数strings，有一个raw属性，也指向一个数组 12345678tag`abc\nefg`;function tag(str) &#123; console.log(str.raw[0]); // abc\nefg&#125;// 充当模板字符串的处理函数，返回一个斜杠都被转义的字符串console.log(String.raw`abc\nefg`); —— 2018/1/3 ES6之Object把表达式放到方括号里，作为对象的属性名 123456let propKey = &apos;foo&apos;;let obj = &#123; [propKey]: true, [&apos;a&apos; + &apos;b&apos;]: &apos;ab&apos;&#125;;console.log(obj.ab); // &quot;ab&quot; 把表达式放到方括号里，作为对象下的方法名 123456let obj = &#123; [&apos;h&apos; + &apos;ello&apos;]() &#123; return &apos;hi&apos;; &#125;&#125;;console.log(obj.hello()); // &quot;hi&quot; 属性名表达式如果是一个对象，默认情况下会自动转化为字符串[object Object] 12345const propKey = &#123;a: 1&#125;;const obj = &#123; [propKey]: 1&#125;;console.log(obj); getter和setter函数name属性在该方法的属性描述对象的get和set属性上面 12345678const obj = &#123; get foo() &#123;&#125;, set foo(x) &#123;&#125;&#125;;const descriptor = Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;);console.log(descriptor.get.name); // &quot;foo&quot;console.log(descriptor.set.name); // &quot;foo&quot; Function构造函数创造的函数，name属性返回anonymous 1console.log((new Function()).name); // anonymous bind方法创造的函数，name属性返回bound加上原函数的名字 12let doSomething = function() &#123;&#125;;console.log(doSomething.bind().name); // bound doSomething Object.is() 同值相等 不同于运算符（===），一是+0不等于-0，二是NaN等于自身 12console.log(Object.is(+0, -0)); // falseconsole.log(Object.is(NaN, NaN)); // true assign 1234567891011121314151617181920212223242526let a = Object.assign(2);console.log(typeof a);// 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错// Object.assign(undefined);// 非首参，undefined和null无法转成对象就会跳过let b = Object.assign(a, undefined);console.log(a === b); //true// 其他类型的值（数值、字符串和布尔值）不会产生效果let c = Object.assign(a, 2, true, undefined);console.log(c);console.log(a === c); // true// Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），// 也不拷贝不可枚举的属性（enumerable: false）// source对象的foo属性是一个取值函数，Object.assign不会复制这个取值函数，// 只会拿到值以后，将这个值复制过去const source = &#123; get foo() &#123;return 1&#125;&#125;;const target = &#123;&#125;;console.log( Object.assign(target, source) ); // &#123;foo: 1&#125; ES6规定，所有class的原型方法都是不可枚举的 12let cd = Object.getOwnPropertyDescriptor(class &#123; foo() &#123; &#125; &#125;.prototype, &apos;foo&apos;).enumerable;console.log(cd); // false Reflect.ownKeys遍历对象属性类型顺序 数字 -&gt; 字符串 -&gt; Symbol 1console.log(Reflect.ownKeys(&#123; [Symbol()]: 0, a: 1, 0: 2 &#125;)); // [&quot;0&quot;, &quot;a&quot;, Symbol()] ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象 1234567const obj = &#123; foo: 123, [Symbol(&apos;aaa&apos;)]: &apos;aaa&apos;, get bar() &#123; return &apos;abc&apos; &#125;&#125;;console.log(Object.getOwnPropertyDescriptors(obj)); getOwnPropertyDescriptors可应用于将两个对象合并，包括set和get 123456const shallowMerge = (target, source) =&gt; Object.defineProperties( target, Object.getOwnPropertyDescriptors(source));console.log(shallowMerge(&#123;&#125;, &#123; set foo(val) &#123; console.log(val) &#125; &#125;)); 对象上部署proto属性，一下三种方法都能达到效果 1234567891011121314151617181920212223let prot = &#123;&#125;;const obj1 = &#123; __proto__: prot, foo: 123&#125;;const obj2 = Object.assign( Object.create(prot), &#123; foo: 123 &#125;);const obj3 = Object.create( prot, Object.getOwnPropertyDescriptors(&#123; foo: 123 &#125;));console.log(&apos;obj1:&apos;, obj1);console.log(&apos;obj2:&apos;, obj2);console.log(&apos;obj3:&apos;, obj3); super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错，super等价于Object.getPrototypeOf(this) 123456789101112131415161718const obj = &#123; a: 2, getShow() &#123; return super.show(); &#125;&#125;;Object.setPrototypeOf( obj, &#123; a: 1, show() &#123; return this.a; &#125; &#125;);console.log(obj.getShow()); // 2 拓展运算符的解构赋值，不能复制继承自原型对象的属性 12345678910111213141516let a = &#123; a: 1 &#125;;let b = &#123; b: 2 &#125;;a.__proto__ = b;let &#123; ...c &#125; = a;console.log(c); // &#123;a: 1&#125;console.log(c.b); // undefined// 变量y和z是扩展运算符的解构赋值，只能读取对象o自身的属性const o = Object.create(&#123; x: 1, y: 2 &#125;);o.z = 3;let &#123; x, ...&#123; y, z &#125; &#125; = o;console.log(x); // 1console.log(y); // undefinedconsole.log(z); // 3 —— 2018/1/4 12345678910&#123; // 有默认值的参数不是尾参数，无法只省略该参数 function f(x = 1, y) &#123; return [x, y]; &#125; // f(, 2); // 报错 // 传入undefined，将触发默认值 console.log(f(undefined, null)); // [1, null]&#125; 123456// 指定默认值后，函数的length属性将失真console.log((function (a, b, c = 5) &#123; &#125;).length); // 2console.log((function (...rest) &#123; &#125;).length); // 0// 设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了console.log((function (a = 5, b, c) &#123; &#125;).length); // 0 —— 2018/1/5 ES6之function箭头函数不能当作构造函数，原因在于箭头函数内部没有this，而是引用外层的this 12345let Fn = () =&gt; &#123; this.age = &apos;20&apos;;&#125;;let fn = new Fn(); // Uncaught TypeError: Fn is not a constructor 箭头函数不能用作 Generator 函数 12345let g = function* () =&gt; &#123; yield 1;&#125;;console.log( g().next() ); // Uncaught SyntaxError: Unexpected token =&gt; 箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this 1234567let res = (function() &#123; return [ (() =&gt; this.x).bind(&#123;x: &apos;inner&apos;&#125;)() ];&#125;).call(&#123;x: &apos;outer&apos;&#125;);console.log(&apos;res:&apos;, res); // [&quot;outer&quot;] “尾调用优化”意义：函数执行到最后一步，不保留外层函数的调用帧，只会保存内部函数调用帧，这样节省了内存。注意，只有不再用到外层函数内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则无法进行“尾调用优化”。 1234567function addOne(a) &#123; var one = 1; function inner(b) &#123; return b + one; // 含有外层变量one &#125; return inner(a);&#125; 尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身，做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。 1234567891011// 普通方法递归function Fibonacci(n) &#123; if(n &lt;= 1) &#123; return 1; &#125; return Fibonacci(n - 1) + Fibonacci(n -2);&#125;console.log(&apos;Fibonacci 100:&apos;, Fibonacci(10)); // 89console.log(&apos;Fibonacci 100:&apos;, Fibonacci(100)); // 堆栈溢出 123456789// 尾递归function tailFibonacci(n, ac1 = 1, ac2 = 1) &#123; if(n &lt;= 1) &#123;return ac2&#125;; return tailFibonacci(n - 1, ac2, ac1 + ac2);&#125;console.log(&apos;tailFibonacci 10:&apos;, tailFibonacci(10)); // 89console.log(&apos;tailFibonacci 100:&apos;, tailFibonacci(100)); // 573147844013817200000 ES6之class继承（续）继承Object子类，有一个行为差异，ES6改变了Object构造函数的行为，发现不是通过new Object()形式调用，Object构造函数忽略参数 12345678class NewObj extends Object &#123; constructor() &#123; super(...arguments); &#125;&#125;let o = new NewObj(&#123;attr: true&#125;);console.log(o.attr === true); //false 将多个类的接口“混入”另一个类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function mix(...mixins) &#123; class Mix&#123;&#125; for(let mixin of mixins) &#123; copyProperties(Mix, mixin); // 拷贝实例属性 copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性 &#125; return Mix;&#125;function copyProperties(target, source) &#123; for(let key of Reflect.ownKeys(source)) &#123; if(key !== &apos;constructor&apos; &amp;&amp; key !== &apos;prototype&apos; &amp;&amp; key !== &apos;name&apos;) &#123; let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); &#125; &#125;&#125;class School &#123; constructor() &#123; this.name = &apos;qing&apos;; &#125; getAddress() &#123; return &apos;beijing&apos;; &#125;&#125;class Student &#123; constructor() &#123; this.name = &apos;wang xiao&apos;; &#125; getAddress() &#123; return&apos;shenzhen&apos;; &#125;&#125;class Ins extends mix(School, Student) &#123;&#125;let ins = new Ins();console.log(ins.getAddress()); —— 2018/1/8 关于从页面外部加载js文件 带有src属性&lt;script&gt; 标签之间还包含JavaScript代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略； 不存在defer和async属性，浏览器就会按照&lt;script&gt;在页面中出现的先后顺序对它们依次进行解析； &lt;script&gt;有defer属性，浏览器会立刻下载，但延时执行（延时到&lt;/html&gt;后执行），HTML5规定按照文件出现的先后顺序执行，先于DOMContentLoaded事件执行； &lt;script&gt;有async属性，浏览器立刻下载，不保证按照先后顺序执行，一定在load事件前执行，但不一定在DOMContentLoaded之前执行； 重绘repaint与重排reflow重绘：当改变那些不会影响元素在网页中的位置样式时，如background-color，border，visibility，浏览器只会用新的样式将元素重绘一次。重排：当改变影响到文本内容或结构，或者元素位置时，重排就会发生。 —— 2018/1/19]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
